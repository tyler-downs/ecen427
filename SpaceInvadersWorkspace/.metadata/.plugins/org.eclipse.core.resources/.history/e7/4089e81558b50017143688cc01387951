/*
 * saucer.c
 *
 *  Created on: Oct 13, 2017
 *      Author: superman
 */
#include "saucer.h"
#include "render.h"

//////////////////////// GLOBAL VARIABLES ///////////////////
static saucer_direction_type saucerDirection = saucer_moves_left;


////////////////////////// FUNCTIONS ////////////////////////
void saucer_drawSaucer()
{
	render_drawObject(saucer_16x7, SAUCER_WIDTH, SAUCER_HEIGHT, (point_t){globals_getSaucerPosition(), SAUCER_POSITION_Y}, GLOBALS_RED, GLOBALS_FORCE_BLACK_BACKGROUND);
}

void eraseSaucer()
{
	render_drawObject(saucer_16x7, SAUCER_WIDTH, SAUCER_HEIGHT, (point_t){globals_getSaucerPosition(), SAUCER_POSITION_Y}, GLOBALS_BLACK, GLOBALS_FORCE_BLACK_BACKGROUND);
}

//Sets the position and draws the saucer if it's going to the right
void initSaucerMovingRight()
{
	//set the position
	globals_setSaucerPosition((int16_t)(SAUCER_WIDTH * -1));
	//draw the saucer there
	saucer_drawSaucer();
}

//Sets the position and draws the saucer if it's going to the left
void initSaucerMovingLeft()
{
	//set the position
	globals_setSaucerPosition((int16_t) GLOBALS_WIDTH_DISPLAY);
	//draw the saucer there
	saucer_drawSaucer();
}

#define SAUCER_MOVE_PIXELS 3
//Moves the saucer right
void saucer_moveSaucerRight()
{
	//erase the rectangle
	render_eraseRectangle((point_t) {globals_getSaucerPosition(), SAUCER_POSITION_Y}, SAUCER_MOVE_PIXELS, SAUCER_HEIGHT);
	//change the start point of the saucer
	int16_t newSaucerPosition = globals_getSaucerPosition() + SAUCER_MOVE_PIXELS;
	//xil_printf("In moveSaucerRight, position = %d\n\r", newSaucerPosition);
	globals_setSaucerPosition(newSaucerPosition);
	//draw the saucer
	//xil_printf("New saucer position: %d\n\r", newSaucerPosition);
	render_drawObject(saucer_16x7, SAUCER_WIDTH, SAUCER_HEIGHT, (point_t){newSaucerPosition, SAUCER_POSITION_Y}, GLOBALS_RED, GLOBALS_FORCE_BLACK_BACKGROUND);
}

//Moves the saucer left
void saucer_moveSaucerLeft()
{
	//erase the rectangle
	render_eraseRectangle((point_t) {globals_getSaucerPosition() + SAUCER_WIDTH*2 - SAUCER_MOVE_PIXELS, SAUCER_POSITION_Y}, SAUCER_MOVE_PIXELS*2, SAUCER_HEIGHT);
	//change the start point of the saucer
	int16_t newSaucerPosition = globals_getSaucerPosition() - SAUCER_MOVE_PIXELS;
	//xil_printf("In moveSaucerLeft, position = %d\n\r", newSaucerPosition);
	globals_setSaucerPosition(newSaucerPosition);
	//draw the saucer
	//xil_printf("New saucer position: %d\n\r", newSaucerPosition);
	render_drawObject(saucer_16x7, SAUCER_WIDTH, SAUCER_HEIGHT, (point_t){newSaucerPosition, SAUCER_POSITION_Y}, GLOBALS_RED, GLOBALS_FORCE_BLACK_BACKGROUND);
}

//Switches the direction the saucer is moving
void saucer_switchSaucerMoveDirection()
{
	//if they're going left, move them right
	if (saucerDirection == saucer_moves_left)
	{
		saucerDirection = saucer_moves_right;
	}
	else //if theyre going right, move them left
	{
		saucerDirection = saucer_moves_left;
	}
}

//returns the current move direction of the saucer
saucer_direction_type saucer_getSaucerDirection()
{
	return saucerDirection;
}

//Prints the random score when the saucer is killed
void printScoreOnSaucerDeath(uint16_t newScore, uint32_t color)
{
	char updatedScore[RENDER_MAX_SCORE_DIGITS] = {'0', '0', '0', '0', '0', '0'}; //initialize the score char array

	//convert the integer score into a char array
	int16_t i = 0;
	for (i = 5; i >= 0; i--)
	{
		updatedScore[i] = (char) ((newScore % 10) + '0');
		//xil_printf("i = %d, newScore = %d, updatedScore[i] = %c\n\r", i, newScore, updatedScore[i]); //TEST
		newScore /= 10;
	}
	//determine the first digit to display (we don't want leading zeros)
	uint16_t m, firstNonzero = RENDER_MAX_SCORE_DIGITS-1;
	for (m = 0 ; m < RENDER_MAX_SCORE_DIGITS; m++)
	{
		if (updatedScore[m] != '0')
		{
			firstNonzero = m;
			break;
		}
	}
	//xil_printf("firstNonzero = %d\n\r", firstNonzero); //TEST
	uint16_t k;
	uint16_t x;
	//write each digit to the screen
	for (k = firstNonzero; k < RENDER_MAX_SCORE_DIGITS; k++)
	{
		//xil_printf("saucerPosition: %d + k-firstNonzero*DW*MM: %d\n\r", getSaucerPosition(), (k-firstNonzero)*(DIGIT_WIDTH*MAGNIFY_MULT));
		x = globals_getSaucerPosition() + (k-firstNonzero)*(RENDER_DIGIT_WIDTH*GLOBALS_MAGNIFY_MULT);
		//xil_printf("x = %d\n\r", x);
		switch(updatedScore[k])
		{
		case '0':
			render_drawObject(zero_5x5, RENDER_DIGIT_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '1':
			render_drawObject(one_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '2':
			render_drawObject(two_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '3':
			render_drawObject(three_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '4':
			render_drawObject(four_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '5':
			render_drawObject(five_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '6':
			render_drawObject(six_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '7':
			render_drawObject(seven_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '8':
			render_drawObject(eight_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		case '9':
			render_drawObject(nine_5x5, RENDER_ONE_WIDTH, RENDER_DIGIT_HEIGHT, (point_t) {x, SAUCER_POSITION_Y}, color, GLOBALS_FORCE_BLACK_BACKGROUND);
			break;
		}
	}
}
